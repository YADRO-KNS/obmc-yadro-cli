#!/bin/bash -eu
#
# YADRO OpenBMC Command Line Interface
# Copyright (C) 2020-2021 YADRO
#
# SPDX-License-Identifier: Apache-2.0
#

# CLI: General BMC configuration

SETTINGS_SERVICE="xyz.openbmc_project.Settings"
TIMESYNC_METHOD_PATH="/xyz/openbmc_project/time/sync_method"
TIMESYNC_METHOD_IFACE="xyz.openbmc_project.Time.Synchronization"
TIMESYNC_METHOD_PROPERTY="TimeSyncMethod"

SYSLOG_CONFIG_SERVICE="xyz.openbmc_project.Syslog.Config"
SYSLOG_CONFIG_PATH="/xyz/openbmc_project/logging/config/remote"
NETWORK_CLIENT_IFACE="xyz.openbmc_project.Network.Client"

# Format date in a non-standard way
function format_date {
  local compact="$1"
  local utc="$2"
  local sec="$3"

  if [[ -n "${compact}" ]] && [[ -n "${utc}" ]]; then
    date --date "@${sec}" --utc +'%F %T UTC'
  elif [[ -n "${compact}" ]]; then
    date --date "@${sec}" +'%F %T UTC%z'
  elif [[ -n "${utc}" ]]; then
    date --date "@${sec}" --utc +'%a %d %b %Y %T UTC'
  else
    date --date "@${sec}" +'%a %d %b %Y %T UTC%z'
  fi
}

# @doc cmd_info
# General BMC information
function cmd_info {
  subcommand "$@"
}

# @doc cmd_info_uptime
# Show BMC uptime
#   -c, --compact   Show last boot time in compact format
#   -u, --utc       Show last boot time in UTC timezone
function cmd_info_uptime {
  local compact=""
  local utc=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --compact) compact="y";;
      -u | --utc) utc="y";;
      *) abort_badarg "$1";;
    esac
    shift
  done

  local sec
  local up
  sec="$(awk -F. '{print $1}' /proc/uptime)"
  up="$(($(date +%s) - sec))"

  printf 'Uptime is %dd %dh %dm %ds.\n' $((sec / 86400)) \
                                        $((sec % 86400 / 3600)) \
                                        $((sec % 3600 / 60)) \
                                        $((sec % 60))
  echo -n "Last BMC start was on "
  format_date "${compact}" "${utc}" "${up}"
}

# @sudo cmd_info_version admin,operator,user
# @doc cmd_info_version
# Show version of BMC and BIOS/UEFI
#   -b, --bmc   Show BMC version
#   -u, --bios  Show BIOS/UEFI version
function cmd_info_version {
  # If no options are given, show everything
  [[ $# -eq 0 ]] && set -- -b -u

  local bmc_match='^BMC '
  local host_match='^Host '
  local no_match='no-match-pattern'
  local bmc=${no_match}
  local host=${no_match}

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b | --bmc) bmc=${bmc_match};;
      -u | --bios) host=${host_match};;
      *) abort_badarg "$1";;
    esac
    shift
  done

  fwupdate --version | grep -E "(${bmc}|${host})"
}

# @doc cmd_datetime
# BMC date and time configuration
function cmd_datetime {
  subcommand "$@"
}

# @sudo cmd_datetime_method admin
# @restrict cmd_datetime_method admin
# @doc cmd_datetime_method
# Change time synchronization method
#  {manual|ntp}
function cmd_datetime_method {
  local method
  method="$(busctl get-property ${SETTINGS_SERVICE} \
                                ${TIMESYNC_METHOD_PATH} \
                                ${TIMESYNC_METHOD_IFACE} \
                                ${TIMESYNC_METHOD_PROPERTY})"
  method=${method##*.}
  method=${method%\"*}

  if [[ $# -eq 0 ]]; then
      echo "Current time synchronization method is ${method}"
  else
    case "${1}" in
      [Mm][Aa][Nn][Uu][Aa][Ll])
        if [[ ${method} != "Manual" ]]; then
          busctl set-property --timeout=60 ${SETTINGS_SERVICE} \
                              ${TIMESYNC_METHOD_PATH} \
                              ${TIMESYNC_METHOD_IFACE} \
                              ${TIMESYNC_METHOD_PROPERTY} s \
                              ${TIMESYNC_METHOD_IFACE}.Method.Manual
        fi
        ;;

      [Nn][Tt][Pp])
        if [[ ${method} != "NTP" ]]; then
          busctl set-property --timeout=60 ${SETTINGS_SERVICE} \
                              ${TIMESYNC_METHOD_PATH} \
                              ${TIMESYNC_METHOD_IFACE} \
                              ${TIMESYNC_METHOD_PROPERTY} s \
                              ${TIMESYNC_METHOD_IFACE}.Method.NTP
        fi
        ;;
      *)
        abort_badarg "Unsupported method specified. Expected manual or ntp."
        ;;
    esac
  fi
}

# @sudo cmd_datetime_set admin
# @restrict cmd_datetime_set admin
# @doc cmd_datetime_set
# Set system time manually
#   YYYY-MM-DD-HH-mm-SS   Time to set
function cmd_datetime_set {
  if [[ $# -eq 0 ]] || [[ $1 =~ ^\d{4}-\d\d-\d\d-\d\d-\d\d-\d\d$ ]]; then
    echo "Please enter date and time in YYYY-MM-DD-HH-mm-SS format" >&2
    return 1
  fi

  local new_date="${1:0:10}"
  local new_time="${1:11}"
  date "${new_date} ${new_time//-/:}"

  echo "System time is updated."
}

# @doc cmd_datetime_show
# Show system time
#   -c, --compact   Show last boot time in compact format
#   -u, --utc       Show last boot time in UTC timezone
function cmd_datetime_show {
  local compact=""
  local utc=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --compact) compact="y";;
      -u | --utc) utc="y";;
      *) abort_badarg "$1";;
    esac
    shift
  done
  format_date "${compact}" "${utc}" "$(date +%s)"
}

function call_netconfig() {
  local FNAME=${FUNCNAME[1]##cmd_}
  local PNAME="bmc ${FNAME//_/ }"
  exec -a "${PNAME}" netconfig --cli "$@"
}

# @sudo cmd_datetime_ntpconfig admin
# @restrict cmd_datetime_ntpconfig admin
# @doc cmd_datetime_ntpconfig
# Configure NTP server connection
function cmd_datetime_ntpconfig {
  if [[ $# -ge 1 && $1 =~ ^-*h(elp)?$ ]]; then
    call_netconfig help ntp
    return
  fi
  if [[ $# -lt 3 ]]; then
    abort_badarg "Expected 3 or more arguments"
  fi
  call_netconfig ntp "$@"
}

# @sudo cmd_ifconfig admin
# @restrict cmd_ifconfig admin
# @doc cmd_ifconfig
# BMC network configuration
function cmd_ifconfig {
  call_netconfig "$@"
}

# @restrict cmd_syslog admin
# @doc cmd_syslog
# Remote logging settings
function cmd_syslog {
  subcommand "$@"
}

# @sudo cmd_syslog_show admin
# @doc cmd_syslog_show
# Show actual remote syslog server
function cmd_syslog_show {
    local addr
    addr="$(busctl get-property ${SYSLOG_CONFIG_SERVICE} \
                                ${SYSLOG_CONFIG_PATH} \
                                ${NETWORK_CLIENT_IFACE} Address \
                                2>/dev/null)"
    addr=${addr#*\"}
    addr=${addr%\"*}

    local port
    port="$(busctl get-property ${SYSLOG_CONFIG_SERVICE} \
                                ${SYSLOG_CONFIG_PATH} \
                                ${NETWORK_CLIENT_IFACE} Port \
                                2>/dev/null)"
    port=${port#* }

    echo -n "Remote syslog server: "
    if [[ -z "${addr}" ]] || [[ "${port}" == "0" ]]; then
        echo "(none)"
    else
        echo -n "${addr}"
        if [[ ! -z "${port}" ]]; then
            echo -n ":${port}"
        fi
        echo
    fi
}

# @sudo cmd_syslog_set admin
# @restrict cmd_syslog_set admin
# @doc cmd_syslog_set
# Configure remote syslog server
#  address[:port] - to change settings
#  empty - to reset settings
function cmd_syslog_set {
    local remote_point=${1:-}
    local address=${remote_point%:*}
    local port=${remote_point#*:}

    if [[ "${port}" == "${remote_point}" ]] || [[ -z "${port}" ]]; then
        port=514
    fi

    busctl set-property ${SYSLOG_CONFIG_SERVICE} \
                        ${SYSLOG_CONFIG_PATH} \
                        ${NETWORK_CLIENT_IFACE} Port q ${port} \
    && \
    busctl set-property ${SYSLOG_CONFIG_SERVICE} \
                        ${SYSLOG_CONFIG_PATH} \
                        ${NETWORK_CLIENT_IFACE} Address s "${address}"
}

# @sudo cmd_syslog_reset admin
# @restrict cmd_syslog_reset admin
# @doc cmd_syslog_reset
# Reset syslog settings. Alias for the syslog set command without arguments.
function cmd_syslog_reset {
    cmd_syslog_set :0
}

# @restrict cmd_config admin
# @doc cmd_config
# BMC config backup and restore
function cmd_config {
  subcommand "$@"
}

# @sudo cmd_config_default admin
# @restrict cmd_config_default admin
# @doc cmd_config_default
# Restore the factory default BMC config
#  -k, --keepipconfig   Keep network settings
function cmd_config_default {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -k | --keepipconfig)
        echo "Option $1 is not supported yet" >&2
        exit 1;;
      *) abort_badarg "$1";;
    esac
    shift
  done
  fwupdate --reset
}

# @restrict cmd_update admin
# @doc cmd_update
# BMC and BIOS update
function cmd_update {
  subcommand "$@"
}

# @sudo cmd_update_start admin
# @restrict cmd_update_start admin
# @doc cmd_update_start
# Update BMC and BIOS.
#  -c, --clearcfg  Reset BMC settings to manufacture defaults
#  -y, --yes       Do not ask for confirmation
#  FILE            Firmware archive to install
function cmd_update_start {
  local fwfile=""
  local reset=""
  local yes=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --clearcfg) reset="--reset";;
      -y | --yes) yes="--yes";;
      *)
        if [[ -n "${fwfile}" ]]; then
          abort_badarg "$1"
        else
          fwfile="$1"
        fi
        ;;
    esac
    shift
  done

  if [[ -z "${fwfile}" ]]; then
    echo "Firmware file not specified" >&2
    return 1
  fi

  fwupdate ${reset} ${yes} -f "${fwfile}"
}

# @sudo cmd_reboot admin
# @restrict cmd_reboot admin
# @doc cmd_reboot
# Reboot the BMC
#  -f, --force     Forced BMC reboot
#  -y, --yes       Do not ask for confirmation
function cmd_reboot {
  local force=""
  local yes=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f | --force) force="y";;
      -y | --yes) yes="y";;
      *) abort_badarg "$1";;
    esac
    shift
  done

  if [[ -n "${force}" ]]; then
    echo -n "BMC will be rebooted gracefully,"
  else
    echo -n "BMC will be rebooted forcefully,"
  fi
  echo " all user sessions including this one will be"
  echo "closed. Host will not be affected."

  if [[ -z "${yes}" ]]; then
    confirm
  fi

  echo "Reboot the BMC..."
  reboot ${force}
}

# @restrict cmd_remoteimage admin
# @doc cmd_remoteimage
# Access to the remote side file
function cmd_remoteimage {
  subcommand "$@"
}

# @sudo cmd_remoteimage_connect admin
# @restrict cmd_remoteimage_connect admin
# @doc cmd_remoteimage_connect
# Connect to the remote server via the specified protocol
#   --nbd <0..10>         use NBD protocol to connect the remote server with specified NBD device number
#   -e,--export <name>    the name of the export
#   address[:port]        remote server address
function cmd_remoteimage_connect {
    local nbd_device=""
    local remote_point=""
    local address=""
    local port=""
    local export_name=""

    while [[ $# -gt 0 ]]; do
      case "${1}" in
        --nbd)
          if [[ $# -lt 2 ]]; then
            echo "The ordinal number of the NBD device is required." >&2
            return 1
          fi
          nbd_device="/dev/nbd${2}"
          shift
          ;;
        -e | --export)
          if [[ $# -lt 2 ]]; then
            echo "The export name of the NBD device is required" >&2
            return 1
          fi
          export_name="--name ${2} "
          shift
          ;;
        *)
          if [[ -n "${remote_point}" ]]; then
            abort_badarg "${1}"
          else
            remote_point="${1}"
          fi
          address="${remote_point%:*}"
          port="${remote_point#*:}"
          ;;
      esac
      shift
    done

    if [[ -z "${nbd_device}" ]]; then
      echo "The NBD device number shall be specified." >&2
      return 1
    fi

    if [[ -z "${port}" ]]; then
        port=10809
    fi

    if [[ -z "${address}" ]] || [[ -z "${port}" ]]; then
      echo "The remote server address shall be specified." >&2
      return 1
    fi

    echo "Connecting to NBD server ${remote_point}..."
    nbd-client ${export_name} "${address}" "${port}" "${nbd_device}"
}

# @sudo cmd_remoteimage_disconnect admin
# @restrict cmd_remoteimage_disconnect admin
# @doc cmd_remoteimage_disconnect
# Disconnect NBD session
#   -y, --yes       do not ask for confirmation
#   --nbd <0..10>   the number of NBD device
function cmd_remoteimage_disconnect {
  local yes=""
  local nbd_device=""

  while [[ $# -gt 0 ]]; do
    case "${1}" in
      -y | --yes) yes="y";;
      --nbd)
        if [[ $# -lt 2 ]] || [[ ${2:0:1} == "-" ]]; then
          echo "The NBD device number shall be specified" >&2
          return 1
        fi
        nbd_device="/dev/nbd${2}"
        shift
        ;;
      *) abort_badarg "${1}";;
    esac
    shift
  done

  if [[ -z "${nbd_device}" ]]; then
    echo "The NBD device number shall be specified." >&2
    return 1
  fi

  if [[ -z "${yes}" ]]; then
    confirm
  fi

  nbd-client -d "${nbd_device}"
}
