#!/bin/bash -eu

#
# Initiate kernel memory dump (kdump) on the host system.
#

# prevent modification of executable path
PATH="/bin:/sbin:/usr/bin:/usr/sbin"

# elevate self privileges
[[ ${EUID} -eq 0 ]] || exec sudo $(realpath ${BASH_SOURCE[0]})

# Execute command.
# Param 1: command description (message text)
# Param 2: command to execute
# Return 0 if command was executed successfully
function exec_cmd {
  local msg="$1"
  local cmd="$2"
  echo -n "${msg}..."
  local out
  if out="$(eval "{ ${cmd}; exit \${PIPESTATUS[0]}; } 2>&1")"; then
    printf "\r%-24s [ OK ]\n" "${msg}"
  else
    printf "\r%-24s [ FAIL ]\n" "${msg}"
    echo "${out}" >&2
    return 1
  fi
}

# Warn user and ask for confirmation.
# return 0 if user has confirmed the action
function confirm {
  echo -e "WARNING!"
  echo "You are going to initiate kernel memory dump (kdump) on the host system."
  echo "This action will inevitably REBOOT the host system!"

  local yn
  read -p "Are you sure? (Type 'yes' to continue) " yn
  if [[ ${yn} != yes ]]; then
    echo "Aborted by user" >&2
    return 1
  fi
}

# Enable/disable OCC control service.
# It is needed to free the I2C channel before pdbg call, because it used
# as communication protocol between BMC and target host's CPU.
# param 1: operation type - "true"=enable/"false"=disable the service
# return 0 if operation was completed successfully
function occ_control {
  local enable="$1"
  if [[ ${enable} == true ]]; then
    local msg="Activate OCC for CPU0"
  elif [[ ${enable} == false ]]; then
    local msg="Disable OCC for CPU0"
  else
    echo "Invalid state: ${enable}" >&2
    exit 1
  fi
  exec_cmd "${msg}" "busctl set-property \
                     org.open_power.OCC.Control \
                     /org/open_power/control/occ0 \
                     org.open_power.OCC.Status OccActive b ${enable}"
}

# Send SRESET signal to the host's CPU via PDBG.
# return 0 if operation was completed successfully
function sreset {
  local pdbg="pdbg --backend=i2c --device=/dev/i2c-4"

  echo -n "Probe for target"
  local target=""
  local core
  for core in {1..12}; do
    local path="pib0/core${core}/thread0"
    if ${pdbg} -P ${path} probe 2>/dev/null | grep -q thread0; then
      target="${path}"
      break
    fi
  done
  if [[ -n "${target}" ]]; then
    echo -e "         [ OK ]"
  else
    echo -e "         [ FAIL ]"
    return 1
  fi

  exec_cmd "Send SRESET" "${pdbg} -P ${target} sreset"
}

# Script entry point
confirm
occ_control false
sreset && SRESET_SENT=y || SRESET_SENT=
occ_control true

if [[ -n "${SRESET_SENT}" ]]; then
  echo "SRESET signal has been sent, expect kdump on the host."
else
  echo "Failed to send SRESET signal." >&2
  exit 1
fi
